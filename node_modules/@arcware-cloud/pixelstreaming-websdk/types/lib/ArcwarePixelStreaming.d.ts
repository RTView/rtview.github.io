import { Messages } from "@arcware-cloud/shared-pixelstreaming-websdk";
import { PixelStreaming } from "@epicgames-ps/lib-pixelstreamingfrontend-ue5.2";
import { PixelStreamingOverrides } from "@epicgames-ps/lib-pixelstreamingfrontend-ue5.2/types/PixelStreaming/PixelStreaming";
import { ArcwareConfig } from "./ArcwareConfig";
import { EventHandler } from "./domain/EventHandler";
import { Session } from "./domain/Session";
import { WebsocketState } from "./domain/ConnectionIdentifier";
export declare class ArcwarePixelStreaming extends PixelStreaming {
    /** Override default config with ArcwareConfig. */
    config: ArcwareConfig;
    streamInfo?: Messages.StreamInfo;
    private webRtcController;
    loveLettersContainer: HTMLDivElement | undefined;
    private loveLettersList;
    private loveLettersQueue;
    private isProcessingQueue;
    private microphoneOverlay;
    /** Returns a list of WebSocketStates of all PixelStreaming Instances generated. */
    get WebsocketStates(): WebsocketState[];
    /** Counts all active PixelStreaming Instances generated. (CONNECTING & CONNECTED) */
    get ActiveInstances(): () => number;
    /** Returns this PixelStreaming Instances websocket state. */
    get websocketState(): WebsocketState;
    constructor(config: ArcwareConfig, overrides?: PixelStreamingOverrides);
    /** Getter for the session object. */
    get session(): Session;
    /**
     * * * * * * *
     *  Listen   *
     * * * * * * *
     */
    /** On version requested, the version of the WebSDK would be returned. */
    private onVersion;
    /** On ping the session creation timestamp will be updated. */
    private onPing;
    /** Handle incoming configurations. */
    private onStreamInfo;
    /** On ping the session creation timestamp will be updated. */
    readonly queueHandler: EventHandler<{
        type: "queue";
        queue: {
            valueType: "milliseconds" | "seconds" | "minutes" | "hours" | "days";
            index?: number | undefined;
            queueLength?: number | undefined;
            waited?: number | undefined;
            estimatedWaitTime?: number | undefined;
            averageWaitTime?: number | undefined;
        };
    }>;
    private onQueue;
    /** Error receiver. */
    readonly errorHandler: EventHandler<{
        type: "error";
        code: number;
        reason: string;
        verbosity: number;
    }>;
    private onError;
    /** LoveLetter */
    readonly loveLetterHandler: EventHandler<{
        type: "letter";
        code: number;
        reason: string;
        verbosity: number;
    }>;
    private onLoveLetter;
    /** SessionId */
    readonly sessionIdHandler: EventHandler<string>;
    private onSessionId;
    /** VideoInitialized */
    readonly videoInitializedHandler: EventHandler<never>;
    private onVideoInitialized;
    /** WebSocket Close */
    readonly websocketOnCloseHandler: EventHandler<CloseEvent>;
    /** Adding a zod-safe handler. */
    private addMessageHandler;
    /**
     * * * * * *
     *  Send   *
     * * * * * *
     */
    private sendStats;
    private send;
    private handleResolutionChange;
    private applyResolutionIfPlaying;
    removePlayer(): void;
    private handleMouseLock;
    private initLoveLettersContainer;
    private pushLetter;
    private processLoveLetterQueue;
    private handleRemoveLoveLetters;
    toggleAudio(videoElement: HTMLVideoElement, enabled: boolean): void;
    private createMicrophoneOverlay;
    toggleMic(enable: boolean, isDefault: boolean): void;
    private wrapWebSocketOnCloseHandler;
    onStreamingStateChange(callback: (isStreaming: boolean) => void): void;
    private removeXRIconIfDisabled;
    private injectCustomUI;
}
